[@@@ocaml.warning "-23-27-30-39-44"]

type file_chunk = {
  mutable _presence: Pbrt.Bitfield.t; (** presence for 3 fields *)
  mutable path : string;
  mutable data : bytes;
  mutable crc : int32;
}

type file_path = {
  mutable _presence: Pbrt.Bitfield.t; (** presence for 1 fields *)
  mutable path : string;
}

type file_crc = {
  mutable _presence: Pbrt.Bitfield.t; (** presence for 1 fields *)
  mutable crc : int32;
}

type empty = unit

type ping = unit

type pong = unit

let default_file_chunk (): file_chunk =
{
  _presence=Pbrt.Bitfield.empty;
  path="";
  data=Bytes.create 0;
  crc=0l;
}

let default_file_path (): file_path =
{
  _presence=Pbrt.Bitfield.empty;
  path="";
}

let default_file_crc (): file_crc =
{
  _presence=Pbrt.Bitfield.empty;
  crc=0l;
}

let default_empty : empty = ()

let default_ping : ping = ()

let default_pong : pong = ()


(** {2 Make functions} *)

let[@inline] file_chunk_has_path (self:file_chunk) : bool = (Pbrt.Bitfield.get self._presence 0)
let[@inline] file_chunk_has_data (self:file_chunk) : bool = (Pbrt.Bitfield.get self._presence 1)
let[@inline] file_chunk_has_crc (self:file_chunk) : bool = (Pbrt.Bitfield.get self._presence 2)

let[@inline] file_chunk_set_path (self:file_chunk) (x:string) : unit =
  self._presence <- (Pbrt.Bitfield.set self._presence 0); self.path <- x
let[@inline] file_chunk_set_data (self:file_chunk) (x:bytes) : unit =
  self._presence <- (Pbrt.Bitfield.set self._presence 1); self.data <- x
let[@inline] file_chunk_set_crc (self:file_chunk) (x:int32) : unit =
  self._presence <- (Pbrt.Bitfield.set self._presence 2); self.crc <- x

let copy_file_chunk (self:file_chunk) : file_chunk =
  { self with path = self.path }

let make_file_chunk 
  ?(path:string option)
  ?(data:bytes option)
  ?(crc:int32 option)
  () : file_chunk  =
  let _res = default_file_chunk () in
  (match path with
  | None -> ()
  | Some v -> file_chunk_set_path _res v);
  (match data with
  | None -> ()
  | Some v -> file_chunk_set_data _res v);
  (match crc with
  | None -> ()
  | Some v -> file_chunk_set_crc _res v);
  _res

let[@inline] file_path_has_path (self:file_path) : bool = (Pbrt.Bitfield.get self._presence 0)

let[@inline] file_path_set_path (self:file_path) (x:string) : unit =
  self._presence <- (Pbrt.Bitfield.set self._presence 0); self.path <- x

let copy_file_path (self:file_path) : file_path =
  { self with path = self.path }

let make_file_path 
  ?(path:string option)
  () : file_path  =
  let _res = default_file_path () in
  (match path with
  | None -> ()
  | Some v -> file_path_set_path _res v);
  _res

let[@inline] file_crc_has_crc (self:file_crc) : bool = (Pbrt.Bitfield.get self._presence 0)

let[@inline] file_crc_set_crc (self:file_crc) (x:int32) : unit =
  self._presence <- (Pbrt.Bitfield.set self._presence 0); self.crc <- x

let copy_file_crc (self:file_crc) : file_crc =
  { self with crc = self.crc }

let make_file_crc 
  ?(crc:int32 option)
  () : file_crc  =
  let _res = default_file_crc () in
  (match crc with
  | None -> ()
  | Some v -> file_crc_set_crc _res v);
  _res

[@@@ocaml.warning "-23-27-30-39"]

(** {2 Formatters} *)

let rec pp_file_chunk fmt (v:file_chunk) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "path" Pbrt.Pp.pp_string fmt v.path;
    if not (file_chunk_has_path v) then Format.pp_print_string fmt "(* absent *)";
    Pbrt.Pp.pp_record_field ~first:false "data" Pbrt.Pp.pp_bytes fmt v.data;
    if not (file_chunk_has_data v) then Format.pp_print_string fmt "(* absent *)";
    Pbrt.Pp.pp_record_field ~first:false "crc" Pbrt.Pp.pp_int32 fmt v.crc;
    if not (file_chunk_has_crc v) then Format.pp_print_string fmt "(* absent *)";
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_file_path fmt (v:file_path) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "path" Pbrt.Pp.pp_string fmt v.path;
    if not (file_path_has_path v) then Format.pp_print_string fmt "(* absent *)";
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_file_crc fmt (v:file_crc) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "crc" Pbrt.Pp.pp_int32 fmt v.crc;
    if not (file_crc_has_crc v) then Format.pp_print_string fmt "(* absent *)";
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_empty fmt (v:empty) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_unit fmt ()
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_ping fmt (v:ping) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_unit fmt ()
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_pong fmt (v:pong) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_unit fmt ()
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

[@@@ocaml.warning "-23-27-30-39"]

(** {2 Protobuf Encoding} *)

let rec encode_pb_file_chunk (v:file_chunk) encoder = 
  if file_chunk_has_path v then (
    Pbrt.Encoder.string v.path encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  );
  if file_chunk_has_data v then (
    Pbrt.Encoder.bytes v.data encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  );
  if file_chunk_has_crc v then (
    Pbrt.Encoder.int32_as_varint v.crc encoder;
    Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  );
  ()

let rec encode_pb_file_path (v:file_path) encoder = 
  if file_path_has_path v then (
    Pbrt.Encoder.string v.path encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  );
  ()

let rec encode_pb_file_crc (v:file_crc) encoder = 
  if file_crc_has_crc v then (
    Pbrt.Encoder.int32_as_varint v.crc encoder;
    Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  );
  ()

let rec encode_pb_empty (v:empty) encoder = 
()

let rec encode_pb_ping (v:ping) encoder = 
()

let rec encode_pb_pong (v:pong) encoder = 
()

[@@@ocaml.warning "-23-27-30-39"]

(** {2 Protobuf Decoding} *)

let rec decode_pb_file_chunk d =
  let v = default_file_chunk () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      file_chunk_set_path v (Pbrt.Decoder.string d);
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(file_chunk), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      file_chunk_set_data v (Pbrt.Decoder.bytes d);
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(file_chunk), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      file_chunk_set_crc v (Pbrt.Decoder.int32_as_varint d);
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(file_chunk), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  (v : file_chunk)

let rec decode_pb_file_path d =
  let v = default_file_path () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      file_path_set_path v (Pbrt.Decoder.string d);
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(file_path), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  (v : file_path)

let rec decode_pb_file_crc d =
  let v = default_file_crc () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      file_crc_set_crc v (Pbrt.Decoder.int32_as_varint d);
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(file_crc), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  (v : file_crc)

let rec decode_pb_empty d =
  match Pbrt.Decoder.key d with
  | None -> ();
  | Some (_, pk) -> 
    Pbrt.Decoder.unexpected_payload "Unexpected fields in empty message(empty)" pk

let rec decode_pb_ping d =
  match Pbrt.Decoder.key d with
  | None -> ();
  | Some (_, pk) -> 
    Pbrt.Decoder.unexpected_payload "Unexpected fields in empty message(ping)" pk

let rec decode_pb_pong d =
  match Pbrt.Decoder.key d with
  | None -> ();
  | Some (_, pk) -> 
    Pbrt.Decoder.unexpected_payload "Unexpected fields in empty message(pong)" pk

[@@@ocaml.warning "-23-27-30-39"]

(** {2 Protobuf YoJson Encoding} *)

let rec encode_json_file_chunk (v:file_chunk) = 
  let assoc = ref [] in
  if file_chunk_has_path v then (
    assoc := ("path", Pbrt_yojson.make_string v.path) :: !assoc;
  );
  if file_chunk_has_data v then (
    assoc := ("data", Pbrt_yojson.make_bytes v.data) :: !assoc;
  );
  if file_chunk_has_crc v then (
    assoc := ("crc", Pbrt_yojson.make_int (Int32.to_int v.crc)) :: !assoc;
  );
  `Assoc !assoc

let rec encode_json_file_path (v:file_path) = 
  let assoc = ref [] in
  if file_path_has_path v then (
    assoc := ("path", Pbrt_yojson.make_string v.path) :: !assoc;
  );
  `Assoc !assoc

let rec encode_json_file_crc (v:file_crc) = 
  let assoc = ref [] in
  if file_crc_has_crc v then (
    assoc := ("crc", Pbrt_yojson.make_int (Int32.to_int v.crc)) :: !assoc;
  );
  `Assoc !assoc

let rec encode_json_empty (v:empty) = 
Pbrt_yojson.make_unit v

let rec encode_json_ping (v:ping) = 
Pbrt_yojson.make_unit v

let rec encode_json_pong (v:pong) = 
Pbrt_yojson.make_unit v

[@@@ocaml.warning "-23-27-30-39"]

(** {2 JSON Decoding} *)

let rec decode_json_file_chunk d =
  let v = default_file_chunk () in
  let assoc = match d with
    | `Assoc assoc -> assoc
    | _ -> assert(false)
  in
  List.iter (function 
    | ("path", json_value) -> 
      file_chunk_set_path v (Pbrt_yojson.string json_value "file_chunk" "path")
    | ("data", json_value) -> 
      file_chunk_set_data v (Pbrt_yojson.bytes json_value "file_chunk" "data")
    | ("crc", json_value) -> 
      file_chunk_set_crc v (Pbrt_yojson.int32 json_value "file_chunk" "crc")
    
    | (_, _) -> () (*Unknown fields are ignored*)
  ) assoc;
  ({
    _presence = v._presence;
    path = v.path;
    data = v.data;
    crc = v.crc;
  } : file_chunk)

let rec decode_json_file_path d =
  let v = default_file_path () in
  let assoc = match d with
    | `Assoc assoc -> assoc
    | _ -> assert(false)
  in
  List.iter (function 
    | ("path", json_value) -> 
      file_path_set_path v (Pbrt_yojson.string json_value "file_path" "path")
    
    | (_, _) -> () (*Unknown fields are ignored*)
  ) assoc;
  ({
    _presence = v._presence;
    path = v.path;
  } : file_path)

let rec decode_json_file_crc d =
  let v = default_file_crc () in
  let assoc = match d with
    | `Assoc assoc -> assoc
    | _ -> assert(false)
  in
  List.iter (function 
    | ("crc", json_value) -> 
      file_crc_set_crc v (Pbrt_yojson.int32 json_value "file_crc" "crc")
    
    | (_, _) -> () (*Unknown fields are ignored*)
  ) assoc;
  ({
    _presence = v._presence;
    crc = v.crc;
  } : file_crc)

let rec decode_json_empty d =
Pbrt_yojson.unit d "empty" "empty record"

let rec decode_json_ping d =
Pbrt_yojson.unit d "ping" "empty record"

let rec decode_json_pong d =
Pbrt_yojson.unit d "pong" "empty record"

module FileServer = struct
  open Pbrt_services.Value_mode
  module Client = struct
    open Pbrt_services
    
    let touch_file : (file_path, unary, empty, unary) Client.rpc =
      (Client.mk_rpc 
        ~package:[]
        ~service_name:"FileServer" ~rpc_name:"touch_file"
        ~req_mode:Client.Unary
        ~res_mode:Client.Unary
        ~encode_json_req:encode_json_file_path
        ~encode_pb_req:encode_pb_file_path
        ~decode_json_res:decode_json_empty
        ~decode_pb_res:decode_pb_empty
        () : (file_path, unary, empty, unary) Client.rpc)
    open Pbrt_services
    
    let upload_file : (file_chunk, stream, file_crc, unary) Client.rpc =
      (Client.mk_rpc 
        ~package:[]
        ~service_name:"FileServer" ~rpc_name:"upload_file"
        ~req_mode:Client.Stream
        ~res_mode:Client.Unary
        ~encode_json_req:encode_json_file_chunk
        ~encode_pb_req:encode_pb_file_chunk
        ~decode_json_res:decode_json_file_crc
        ~decode_pb_res:decode_pb_file_crc
        () : (file_chunk, stream, file_crc, unary) Client.rpc)
    open Pbrt_services
    
    let download_file : (file_path, unary, file_chunk, stream) Client.rpc =
      (Client.mk_rpc 
        ~package:[]
        ~service_name:"FileServer" ~rpc_name:"download_file"
        ~req_mode:Client.Unary
        ~res_mode:Client.Stream
        ~encode_json_req:encode_json_file_path
        ~encode_pb_req:encode_pb_file_path
        ~decode_json_res:decode_json_file_chunk
        ~decode_pb_res:decode_pb_file_chunk
        () : (file_path, unary, file_chunk, stream) Client.rpc)
    open Pbrt_services
    
    let ping_pong : (ping, stream, pong, stream) Client.rpc =
      (Client.mk_rpc 
        ~package:[]
        ~service_name:"FileServer" ~rpc_name:"ping_pong"
        ~req_mode:Client.Stream
        ~res_mode:Client.Stream
        ~encode_json_req:encode_json_ping
        ~encode_pb_req:encode_pb_ping
        ~decode_json_res:decode_json_pong
        ~decode_pb_res:decode_pb_pong
        () : (ping, stream, pong, stream) Client.rpc)
  end
  
  module Server = struct
    open Pbrt_services
    
    let touch_file : (file_path,unary,empty,unary) Server.rpc = 
      (Server.mk_rpc ~name:"touch_file"
        ~req_mode:Server.Unary
        ~res_mode:Server.Unary
        ~encode_json_res:encode_json_empty
        ~encode_pb_res:encode_pb_empty
        ~decode_json_req:decode_json_file_path
        ~decode_pb_req:decode_pb_file_path
        () : _ Server.rpc)
    
    let upload_file : (file_chunk,stream,file_crc,unary) Server.rpc = 
      (Server.mk_rpc ~name:"upload_file"
        ~req_mode:Server.Stream
        ~res_mode:Server.Unary
        ~encode_json_res:encode_json_file_crc
        ~encode_pb_res:encode_pb_file_crc
        ~decode_json_req:decode_json_file_chunk
        ~decode_pb_req:decode_pb_file_chunk
        () : _ Server.rpc)
    
    let download_file : (file_path,unary,file_chunk,stream) Server.rpc = 
      (Server.mk_rpc ~name:"download_file"
        ~req_mode:Server.Unary
        ~res_mode:Server.Stream
        ~encode_json_res:encode_json_file_chunk
        ~encode_pb_res:encode_pb_file_chunk
        ~decode_json_req:decode_json_file_path
        ~decode_pb_req:decode_pb_file_path
        () : _ Server.rpc)
    
    let ping_pong : (ping,stream,pong,stream) Server.rpc = 
      (Server.mk_rpc ~name:"ping_pong"
        ~req_mode:Server.Stream
        ~res_mode:Server.Stream
        ~encode_json_res:encode_json_pong
        ~encode_pb_res:encode_pb_pong
        ~decode_json_req:decode_json_ping
        ~decode_pb_req:decode_pb_ping
        () : _ Server.rpc)
    
    let make
      ~touch_file:__handler__touch_file
      ~upload_file:__handler__upload_file
      ~download_file:__handler__download_file
      ~ping_pong:__handler__ping_pong
      () : _ Server.t =
      { Server.
        service_name="FileServer";
        package=[];
        handlers=[
           (__handler__touch_file touch_file);
           (__handler__upload_file upload_file);
           (__handler__download_file download_file);
           (__handler__ping_pong ping_pong);
        ];
      }
  end
  
end
