[@@@ocaml.warning "-23-27-30-39-44"]

type person = {
  mutable _presence: Pbrt.Bitfield.t; (** presence for 1 fields *)
  mutable name : string;
  mutable id : int32;
  mutable email : string;
  mutable phone : string list;
  mutable details : (string, string) Hashtbl.t;
}

let default_person (): person =
{
  _presence=Pbrt.Bitfield.empty;
  name="";
  id=0l;
  email="";
  phone=[];
  details=Hashtbl.create 8;
}


(** {2 Make functions} *)

let[@inline] person_has_email (self:person) : bool = (Pbrt.Bitfield.get self._presence 0)

let[@inline] person_set_name (self:person) (x:string) : unit =
  self.name <- x
let[@inline] person_set_id (self:person) (x:int32) : unit =
  self.id <- x
let[@inline] person_set_email (self:person) (x:string) : unit =
  self._presence <- (Pbrt.Bitfield.set self._presence 0); self.email <- x
let[@inline] person_set_phone (self:person) (x:string list) : unit =
  self.phone <- x
let[@inline] person_set_details (self:person) (x:(string, string) Hashtbl.t) : unit =
  self.details <- x

let copy_person (self:person) : person =
  { self with name = self.name }

let make_person 
  ~(name:string) 
  ~(id:int32) 
  ?(email:string option)
  ?(phone=[])
  ?(details=Hashtbl.create 8)
  () : person  =
  let _res = default_person () in
  person_set_name _res name;
  person_set_id _res id;
  (match email with
  | None -> ()
  | Some v -> person_set_email _res v);
  person_set_phone _res phone;
  person_set_details _res details;
  _res

[@@@ocaml.warning "-23-27-30-39"]

(** {2 Formatters} *)

let rec pp_person fmt (v:person) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "id" Pbrt.Pp.pp_int32 fmt v.id;
    Pbrt.Pp.pp_record_field ~first:false "email" Pbrt.Pp.pp_string fmt v.email;
    if not (person_has_email v) then Format.pp_print_string fmt "(* absent *)";
    Pbrt.Pp.pp_record_field ~first:false "phone" (Pbrt.Pp.pp_list Pbrt.Pp.pp_string) fmt v.phone;
    Pbrt.Pp.pp_record_field ~first:false "details" (Pbrt.Pp.pp_hastable Pbrt.Pp.pp_string Pbrt.Pp.pp_string) fmt v.details;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

[@@@ocaml.warning "-23-27-30-39"]

(** {2 Protobuf Encoding} *)

let rec encode_pb_person (v:person) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.id encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  if person_has_email v then (
    Pbrt.Encoder.string v.email encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  );
  Pbrt.List_util.rev_iter_with (fun x encoder ->
    Pbrt.Encoder.string x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.phone encoder;
  let encode_key = Pbrt.Encoder.string in
  let encode_value = (fun x encoder ->
    Pbrt.Encoder.string x encoder;
  ) in
  Hashtbl.iter (fun k v ->
    let map_entry = (k, Pbrt.Bytes), (v, Pbrt.Bytes) in
    Pbrt.Encoder.map_entry ~encode_key ~encode_value map_entry encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.details;
  ()

[@@@ocaml.warning "-23-27-30-39"]

(** {2 Protobuf Decoding} *)

let rec decode_pb_person d =
  let v = default_person () in
  let continue__= ref true in
  let id_is_set = ref false in
  let name_is_set = ref false in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      (* put lists in the correct order *)
      person_set_phone v (List.rev v.phone);
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      person_set_name v (Pbrt.Decoder.string d); name_is_set := true;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(person), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      person_set_id v (Pbrt.Decoder.int32_as_varint d); id_is_set := true;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(person), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      person_set_email v (Pbrt.Decoder.string d);
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(person), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      person_set_phone v ((Pbrt.Decoder.string d) :: v.phone);
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(person), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      let decode_value = (fun d ->
        Pbrt.Decoder.string d
      ) in
      let a, b = (Pbrt.Decoder.map_entry d ~decode_key:Pbrt.Decoder.string ~decode_value) in
      Hashtbl.add v.details a b;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(person), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  begin if not !id_is_set then Pbrt.Decoder.missing_field "id" end;
  begin if not !name_is_set then Pbrt.Decoder.missing_field "name" end;
  (v : person)
